---
title: DataStructure Questions
layout: layouts/page.njk
permalink: /questions/datastructure-questions/index.html
---
* [참고자료](http://blog.naver.com/PostView.nhn?blogId=kiminhovator&logNo=220327380723&parentCategoryNo=&categoryNo=35&viewDate=&isShowPopularPosts=false&from=postView)

* [해시함수 참고자료](https://ratsgo.github.io/data%20structure&algorithm/2017/10/25/hash/)

선형구조: 배열, 연결리스트, 스택, 큐
비선형구조 : 트리, 그래프

1. 배열 vs 연결리스트
  - 배열은 자료에의 접근은 빠르지만, 메모리 공간활용에 제약이 있다.
  - 연결리스트는 메모리 공간활용이 효율적이지만, 자료에의 접근이 다소 느리다.
  - 배열은 데이터를 물리적 주소에 순차적으로 저장하여 인덱스를 가지고 있어 바로 접근할 수 있기 때문에 접근 속도가 빠르다. 그러나, 배열은 크기가 고정되어 있기 때문에 처음 지정된 사이즈보다 더 많은 데이터를 넣으려면 배열의 크기를 늘리는 연산을 해야되고, 데이터 삽입/삭제시 해당 위치 다음칸에 있는 데이터를 모두 한칸씩 뒤로 밀거나 앞으로 당겨오는 연산을 해야하기 때문에 데이터 삽입/삭제에는 약하다.
  - 연결리스트는 데이터를 저장할 때 데이터만 저장하는 것이 아니라 다음 데이터의 물리적 주소까지 같이 저장한다. 단순 연결리스트는 다음 데이터의 주소를, 이중 연결리스트는 이전 주소와 다음 주소를 모두 저장. 특정 데이터에 접근할 때 인덱스로 바로 접근할 수 있었던 배열과 달리 첫 노드부터 원하는 노드까지 링크를 따라가야 접근이 가능하기 때문에 배열에 비해 접근 속도는 떨어진다. 하지만 반대로, 데이터를 삽입/삭제 할 때에는 물리적 주소에 구애받지 않고 앞/뒤 노드의 주소만 끼워넣을 노드의 주소로 바꿔주면 되기 때문에 삽입/삭제는 배열보다 빠르다.

2. 스택 - LIFO(Last In First Out) 형식의 자료 구조 즉 가장 최근에 스택에 추가한 항목이 가장 먼저 제거될 항목이다.
  - pop() : 스택에서 가장 위에 있는 항목을 제거한다.
  - push(item) : item 하나를 스택의 가장 윗 부분에 추가한다.
  - peek() : 스택의 가장 위에 있는 항목을 반환한다.
  - isEmpty() : 스택이 비어 있을 때에 true 반환한다.

3. 큐 - FIFO(First-In-First-Out)을 따른다.
  - add(item) : item을 리스트의 끝부분에 추가한다.
  - remove() : 리스트의 첫 번째 항목을 제거한다.
  - peek() : 큐에서 가장 위에 있는 항목을 반환한다.
  - isEmpty() : 큐가 비어있을 때 true를 반환한다.

4. 데크 - 삽입과 삭제가 리스트의 양쪽 끝에서 모두 발생하는 자료구조

5. 트리 - 노드와 선분으로 구성된 그래프의 특수한 형태로 가족의 계보, 연산 수식, 회사 조직도 등 표현 적합
  - 노드 : 트리의 기본 요소로서 자료 항목과 다른 항목에 대한 가지를 합친 것
  - 근 노드(Root Node) : 트리의 맨 위에 있는 노드
  - 디그리(차수) : 각 노드에서 뻗어나온 가지 수
  - 트리의 디그리 : 노드들의 디그리 중에서 가장 많은 수
  - 단말 노드 : 자식이 하나도 없는 노드
  - 비단말 노드 : 자식을 하나라도 가지는 노드
  - 자식 노드 : 어떤 노드에 연결된 다음 레벨의 노드들
  - 부모 노드 : 어떤 노드에 연결된 이전 레벨의 노드
  - 형제 노드 : 동일한 부모를 가지는 노드들
  - 레벨 : 근 노드를 기준으로 한 칸씩 내려가면서 레벨이 +1 된다
  - 깊이 : 어떤 트리에서 노드가 가질수 있는 최대의 레벨

6. 빅O표기법
  - O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2ⁿ) < O(n!) < O(nⁿ)
  - O(1) : 스택에서 push, pop
  - O(log n) : 이진트리 (binary search)
  - O(n) : for문
  - O(n log n) : 퀵 정렬, 병합 정렬, 힙 정렬
  - O(n2 - n제곱) : 이중 for문, 삽입정렬, 거품정렬, 선택정렬
  - O(2n - 2의 n승) :  피보나치 수열
